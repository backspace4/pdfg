#+TITLE: Java Applet Exploits (1) CVE-2012-1723
#+AUTHOR: Yuu Nakamura
#+EMAIL: u.ramukana@gmail.com

* What is Java
 + Java is a programming language and computing platform first released by Sun Microsystems in 1995.
    [[file:./220px-James_Gosling_2008.jpg]]
[[http://www.java.com/en/download/faq/whatis_java.xml][ref.1 http://www.java.com/en/download/faq/whatis_java.xml]]

 + The Java byte codes run on the Java Virtual Machine
   [[file:getStarted-compiler.gif]]
[[http://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html][ref.2 http://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html]]

** Java Virtual Machine (JVM)
 + The Java virtual machine knows nothing of the Java programming language, only
   of a particular binary format, the class file format. A class file contains
   Java virtual machine instructions (or bytecodes) and a symbol table, as well
   as other ancillary information.
   [[http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html#jvms-1.2][ref.3 http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html#jvms-1.2]]

 + There are several imprementations
   | name    | developer              |
   |---------+------------------------|
   | HotSpot | Oracle Corporation     |
   | IceTea  | Red Hat, GNU Classpath |
   | J9      | IBM                    |

** HostSpot
   + HotSpot is a Java virtual machine , maintained and distributed by Oracle Corporation
   + adaptive optimization(just-in-time compilation + interpreter)

* security ferture
  + access scope(public, private, protected)
  + memory safety(GC, no use of pointer)
  + type safety(compiler + jvm)
    + bytecode verification
      A step in the linking process of a class where the methods bytecodes are 
      analyzed to ensure type-safety.
      Standard Java compilers produce valid classfiles and type-safe code, but
      the JVM can't guarantee that the code was produced by a trustworthy 
      compiler, so it must reestablish that type-safety through a process at 
      link-time called bytecode verification.
      [[http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Bytecode%20Verifier%20and%20Format%20Checker|outline][ref.4 http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Bytecode%20Verifier%20and%20Format%20Checker|outlin]]
  + sandbox(depends on type safety, which depends on class loader, verifier, security manager)
        
* Java Applets
 + a special kind of Java program
 + a subclass of the java.applet.Applet class
 + executed in the sandbox

** sandbox for unsigned applet
 + Applet instantiate only one SecurityManager (enforce security policy) 
   - network access :: cannot do cross domain network access
   - client resources :: cannnot r/w file system on the client
   - ClassLoader :: cannot create
   [[http://docs.oracle.com/javase/tutorial/deployment/applet/security.html][ref.5 http://docs.oracle.com/javase/tutorial/deployment/applet/security.html]]
 + Applet Class Loader prevents class spoofing
 + Verifier verifies instructions(prevents type confusion)

* Type Confusion Attack
 + see this [[http://www.blackhat.com/presentations/bh-asia-02/LSD/bh-asia-02-lsd.pdf][ref.6 http://www.blackhat.com/presentations/bh-asia-02/LSD/bh-asia-02-lsd.pdf]]
 + 
* CVE-2012-1723
 + Oracle Java SE 7 update 4 and earlier, 6 update 32 and earlier
 + Invalid bytecode verifier leads to insufficent type checks
   + allows Type Confusion Attack
** Bytecode Verifier の話をもう一度
 + クラスのロード時、bytecode verifier はそのクラスのメソッドを確認する
 + 最適化のために確認を後回しにする場合もある(遅延解決)
   + 最初に実行されるまで
   + JIT compile されるまで
** 脆弱性の原因となるバグ
 + HotSpot コンパイラは JIT コンパイルのために field access instructions を遅延解決する場合に誤った最適化を行う
 + １つのfieldを参照する2つの field access instruction が1つのメソッドにある場合、参照されるfieldは1度しか検証されず、その結果はキャッシュされる
 + field access instruction には以下の4つがあるが、検証されるべき内容はそれぞれ異なる
    | Mnemonic  | Opcode(in hex) | Other bytes    | Description                               |
    |-----------+----------------+----------------+-------------------------------------------|
    | getstatic | b2             | index1, index2 | get a static field value of a class       |
    | putstatic | b3             | index1, index2 | set static field to value in a class      |
    | getfield  | b4             | index1, index2 | get a field value of an object objectref  |
    | putfield  | b5             | index1, index2 | set field to value in an object objectref |
 + getstatic したフィールドに putfield できてしまう
 + malicious code(jad -af Confuse.class)
   #+BEGIN_SRC java
public class Confuser
{

    public Confuser()
    {
    //    0    0:aload_0         
    //    1    1:invokespecial   #111 <Method void Object()>
    //    2    4:return          
    }

    public ConfusingClassLoader confuse(ClassLoader classloader)
    {
        if(classloader == null)
    //*   0    0:aload_1         
    //*   1    1:ifnonnull       6
            return null;
    //    2    4:aconst_null     
    //    3    5:areturn         
        ClassLoader _tmp = staticTypeA;
    //    4    6:getstatic       #115 <Field java.lang.ClassLoader cve1723.Confuser.staticTypeA> b2 00 73 
    //    5    9:pop             57 
        staticTypeA = classloader;
    //    6   10:aload_0         2a 
    //    7   11:aload_1         2b 
    //    8   12:putfield        #115 <Field java.lang.ClassLoader cve1723.Confuser.staticTypeA> b5 00 73
        if(instanceTypeB0 != null)
   #+END_SRC
 + normal code(jad -af test.class)
   #+BEGIN_SRC java
public class test
{

    public test()
    {
    //    0    0:aload_0
    //    1    1:invokespecial   #1   <Method void Object()>
    //    2    4:return
    }

    public String confuse(String s)
    {
        String s1 = staticTypeA;
    //    0    0:getstatic       #2   <Field java.lang.String test.staticTypeA>
    //    1    3:astore_2
        staticTypeA = s;
    //    2    4:aload_1
    //    3    5:putstatic       #2   <Field java.lang.String test.staticTypeA>
        return s1;
    //    4    8:aload_2
    //    5    9:areturn
    }

    static String staticTypeA;
}
   #+END_SRC
* JVM byte codes

* The Constant Pool
  - Java virtual machine instructions do not rely on the runtime layout of
    classes, interfaces, class instances, or arrays. Instead, instructions refer
    to symbolic information in the constant_pool table.
#+BEGIN_SRC c++
    cp_info {
       u1 tag;
       u1 info[];
    }

    CONSTANT_Fieldref_info {
       u1 tag;
       u2 class_index;
       u2 name_and_type_index;
    }

    CONSTANT_Class_info {
       u1 tag;
       u2 name_index;
    }

    CONSTANT_Utf8_info {
       u1 tag;
       u2 length;
       u1 bytes[length];
    }
#+END_SRC

* Accessing the Runtime Constant Pool
  - Many numeric constants, as well as objects, fields, and methods, are accessed
    via the runtime constant pool of the current class. Object access is
    considered later (§3.8). Data of types int, long, float, and double, as wel
    as references to instances of class String, are managed using the ldc, ldc_w,
    and ldc2_w instructions.
